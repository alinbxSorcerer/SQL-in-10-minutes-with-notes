# Lesson 5. Advanced Data Filtering

In this lesson, you’ll learn how to combine WHERE clauses to create powerful and sophisticated search conditions. You’ll also learn how to use the NOT and IN operators.

## Combining WHERE Clauses

All the WHERE clauses introduced in Lesson 4, “Filtering Data,” filter data using a single criteria. For a greater degree of filter control, SQL lets you specify multiple WHERE clauses. These clauses may be used in two ways: as AND clauses or as OR clauses.

> **Operator A** 
>
> special keyword used to join or change clauses within a WHERE clause. Also known as logical operators
>
> Combine这个单词用得好..

### Using the AND Operator

To filter by more than one column, you use the AND operator to append conditions to your WHERE clause. The following code demonstrates this:

```python
MySQL [distributor]> select prod_id, prod_price, prod_name
    -> from products
    -> where vend_id = "DLL01" and prod_price <= 4;
+---------+------------+---------------------+
| prod_id | prod_price | prod_name           |
+---------+------------+---------------------+
| BNBG01  |       3.49 | Fish bean bag toy   |
| BNBG02  |       3.49 | Bird bean bag toy   |
| BNBG03  |       3.49 | Rabbit bean bag toy |
+---------+------------+---------------------+
3 rows in set (0.099 sec)
```

The above SQL statement retrieves the product name and price for all products made by vendor DLL01 as long as the price is`$4` or less. The WHERE clause in this SELECT statement is made up of two conditions, and the keyword AND is used to join them. AND instructs the database management system software to return only rows that meet all the conditions specified. If a product is made by vendor DLL01, but it costs more than `$4`, it is not retrieved. Similarly, products that cost less than $4 that are made by a vendor other than the one specified are not to be retrieved. The output generated by this SQL statement is as follows:

> **AND**
>
>  A keyword used in a WHERE clause to specify that only rows matching all the specified conditions should be retrieved.

The example just used contained a single AND clause and was thus made up of two filter conditions. Additional filter conditions could be used as well, each separated by an AND keyword.

> **Note: No ORDER BY Clause Specified** 
>
> In the interests of saving space (and your typing) I omitted ORDER BY clause in many of these examples. As such, it is entirely possible that your output won’t exactly match the output in the book. While the number of returned rows should always match, their order may not. Of course, feel free to add an ORDER BY clause if you’d like, it needs to go after the WHERE clause.



### Using the OR Operator

The OR operator is exactly the opposite of AND. The OR operator instructs the database management system software to retrieve rows that match either condition. In fact, most of the better DBMSs will not even evaluate the second condition in an OR WHERE clause if the first condition has already been met. (If the first condition was met, the row would be retrieved regardless of the second condition.)

Look at the following SELECT statement:

```python
MySQL [distributor]> select prod_name, prod_price 
    -> from products
    -> where vend_id="DLL01" OR vend_id = "BRS01";
+---------------------+------------+
| prod_name           | prod_price |
+---------------------+------------+
| Fish bean bag toy   |       3.49 |
| Bird bean bag toy   |       3.49 |
| Rabbit bean bag toy |       3.49 |
| 8 inch teddy bear   |       5.99 |
| 12 inch teddy bear  |       8.99 |
| 18 inch teddy bear  |      11.99 |
| Raggedy Ann         |       4.99 |
+---------------------+------------+
7 rows in set (0.029 sec)
```

The above SQL statement retrieves the product name and price for any products made by **either** of the two specified vendors. The OR operator tells the DBMS to match either condition, not both. If an AND operator had been used here, no data would be returned (as it would have created a WHERE clause that would match no rows). The output generated by this SQL statement is as follows:

> **OR** 
>
> A keyword used in a WHERE clause to specify that any rows matching either of the specified conditions should be retrieved.



### Understanding Order of Evaluation

**WHERE clauses can contain any number of AND and OR operators.** Combining the two enables you to perform **sophisticated** and complex filtering.

But combining AND and OR operators presents an interesting problem. To demonstrate this, look at an example. You need a list of all products costing $10 or more made by vendors DLL01 and BRS01. The following SELECT statement uses a combination of AND and OR operators to build a WHERE clause:

```python
MySQL [distributor]> select prod_name, prod_price
    -> from products
    -> where vend_id = "DLL01" or vend_Id = "BRS01" and prod_price >= 10;
+---------------------+------------+
| prod_name           | prod_price |
+---------------------+------------+
| Fish bean bag toy   |       3.49 |
| Bird bean bag toy   |       3.49 |
| Rabbit bean bag toy |       3.49 |
| 18 inch teddy bear  |      11.99 |
| Raggedy Ann         |       4.99 |
+---------------------+------------+
5 rows in set (0.081 sec)
```

Look at the results above. Four of the rows returned have prices less than `$10`—so, obviously, the rows were not filtered as intended. Why did this happen? The answer is the order of evaluation. SQL (like most languages) processes AND operators before OR operators. When SQL sees the above WHERE clause, it reads any products costing $10 or more made by vendor BRS01, and any products made by vendor DLL01 regardless of price. In other words, because AND ranks higher in the order of evaluation, the wrong operators were joined together.

The solution to this problem is to use parentheses to explicitly group related operators. Take a look at the following SELECT statement and output:

```python
MySQL [distributor]> select prod_name, prod_price
    -> from products
    -> where (vend_id = "DLL01" or vend_id = "BRS01") and prod_price >= 10;
+--------------------+------------+
| prod_name          | prod_price |
+--------------------+------------+
| 18 inch teddy bear |      11.99 |
+--------------------+------------+
1 row in set (0.011 sec)
```

The only difference between this SELECT statement and the earlier one is that, in this statement, the first two WHERE clause conditions are enclosed within parentheses. As parentheses have a higher order of evaluation than either AND or OR operators, the DBMS first filters the OR condition within those parentheses. The SQL statement then becomes any products made by either vendor DLL01 or vendor BRS01 costing $10 or greater, which is exactly what we want.

> **Tip: Using Parentheses in WHERE Clauses** 
>
> Whenever you write WHERE clauses that use both AND and OR operators, use parentheses to explicitly group operators. Don’t ever rely on the default evaluation order, even if it is exactly what you want. There is no downside to using parentheses, and you are always better off eliminating any ambiguity.



## Using the IN Operator



The IN operator is used to specify a range of conditions, any of which can be matched. IN takes a comma-delimited list of valid values, all enclosed within parentheses. The following example demonstrates this:

```python
MySQL [distributor]> select prod_name, prod_price from products where vend_id in ("dll01", "brs01") order by prod_name;
+---------------------+------------+
| prod_name           | prod_price |
+---------------------+------------+
| 12 inch teddy bear  |       8.99 |
| 18 inch teddy bear  |      11.99 |
| 8 inch teddy bear   |       5.99 |
| Bird bean bag toy   |       3.49 |
| Fish bean bag toy   |       3.49 |
| Rabbit bean bag toy |       3.49 |
| Raggedy Ann         |       4.99 |
+---------------------+------------+
7 rows in set (0.000 sec)
```

The SELECT statement retrieves all products made by vendor DLL01 and vendor BRS01. The IN operator is followed by a comma-delimited list of valid values, and the entire list must be enclosed within parentheses.

If you are thinking that the IN operator **accomplishes** the same goal as OR, you are right. The following SQL statement accomplishes the exact same thing as the example above:

```python
MySQL [distributor]> select prod_name, prod_price from products where vend_id = "DLL01" or vend_id = "BRS01" order by prod_name;
+---------------------+------------+
| prod_name           | prod_price |
+---------------------+------------+
| 12 inch teddy bear  |       8.99 |
| 18 inch teddy bear  |      11.99 |
| 8 inch teddy bear   |       5.99 |
| Bird bean bag toy   |       3.49 |
| Fish bean bag toy   |       3.49 |
| Rabbit bean bag toy |       3.49 |
| Raggedy Ann         |       4.99 |
+---------------------+------------+
7 rows in set (0.014 sec)
```

Why use the IN operator? The advantages are

- When you are working with long lists of valid options, the IN operator syntax is far cleaner and easier to read.
-  The order of evaluation is easier to manage when IN is used in conjunction with other AND and OR operators.
- IN operators almost always execute more quickly than lists of OR operators (although you’ll not see any performance difference with very short lists like the ones we’re using here).
-  The biggest advantage of IN is that the IN operator can contain another SELECT statement, enabling you to build highly dynamic WHERE clauses. You’ll look at this in detail in Lesson 11, “Working with Subqueries.”



## Using the NOT Operator

The WHERE clause’s NOT operator has one function and one function only—NOT negates whatever condition comes next. Because NOT is never used by itself (it is always used in conjunction with some other operator), its syntax is a little different from all other operators. Unlike other operators, the NOT keyword can be used before the column to filter on, not just after it.

> **NOT** 
>
> A keyword used in a WHERE clause to negate a condition.

The following example demonstrates the use of NOT. To list the products made by all vendors except vendor DLL01, you can write the following:

```python
MySQL [distributor]> select prod_name
    -> from products
    -> where not vend_id = "DLL01"
    -> order by prod_name;
+--------------------+
| prod_name          |
+--------------------+
| 12 inch teddy bear |
| 18 inch teddy bear |
| 8 inch teddy bear  |
| King doll          |
| Queen doll         |
+--------------------+
5 rows in set (0.013 sec)
```

The NOT here negates the condition that follows it; so instead of matching vend_id to DLL01, the DBMS matches vend_id to anything that is not DLL01.

Why use NOT? Well, for simple WHERE clauses such as the ones shown here, there really is no advantage to using NOT. NOT is useful in more complex clauses. For example, using NOT in conjunction with an IN operator makes it simple to find all rows that do not match a list of criteria.

> **Note: NOT in MariaDB**
>
> MariaDB supports the use of NOT to negate IN, BETWEEN, and EXISTS clauses. This is different from most DBMSs that allow NOT to be used to negate any conditions.



## Summary

This lesson picked up where the last lesson left off and taught you how to combine WHERE clauses with the AND and OR operators. You also learned how to explicitly manage the order of evaluation and how to use the IN and NOT operators.







### `Q()` objects[¶](https://docs.djangoproject.com/en/dev/ref/models/querysets/#q-objects)

- *class* `Q`[[source\]](https://docs.djangoproject.com/en/dev/_modules/django/db/models/query_utils/#Q)[¶](https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.Q)


A `Q()` object, like an [`F`](https://docs.djangoproject.com/en/dev/ref/models/expressions/#django.db.models.F) object, encapsulates a SQL expression in a Python object that can be used in database-related operations.

In general, `Q() objects` make it possible to define and reuse conditions. This permits the [construction of complex database queries](https://docs.djangoproject.com/en/dev/topics/db/queries/#complex-lookups-with-q) using `|` (`OR`) and `&` (`AND`) operators; in particular, it is not otherwise possible to use `OR` in `QuerySets`.





## Complex lookups with `Q` objects[¶](https://docs.djangoproject.com/en/dev/topics/db/queries/#complex-lookups-with-q-objects)

Keyword argument queries – in [`filter()`](https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.filter), etc. – are “AND”ed together. If you need to execute more complex queries (for example, queries with `OR` statements), you can use [`Q objects`](https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.Q).

A [`Q object`](https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.Q) (`django.db.models.Q`) is an object used to encapsulate a collection of keyword arguments. These keyword arguments are specified as in “Field lookups” above.

For example, this `Q` object encapsulates a single `LIKE` query:

```
from django.db.models import Q
Q(question__startswith='What')
```

`Q` objects can be combined using the `&` and `|` operators. When an operator is used on two `Q` objects, it yields a new `Q` object.

For example, this statement yields a single `Q` object that represents the “OR” of two `"question__startswith"` queries:

```
Q(question__startswith='Who') | Q(question__startswith='What')
```

This is equivalent to the following SQL `WHERE` clause:

```
WHERE question LIKE 'Who%' OR question LIKE 'What%'
```

You can compose statements of arbitrary complexity by combining `Q` objects with the `&` and `|` operators and use parenthetical grouping. Also, `Q` objects can be negated using the `~` operator, allowing for combined lookups that combine both a normal query and a negated (`NOT`) query:

```
Q(question__startswith='Who') | ~Q(pub_date__year=2005)
```

Each lookup function that takes keyword-arguments (e.g. [`filter()`](https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.filter), [`exclude()`](https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.exclude), [`get()`](https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.get)) can also be passed one or more `Q` objects as positional (not-named) arguments. If you provide multiple `Q` object arguments to a lookup function, the arguments will be “AND”ed together. For example:

```
Poll.objects.get(
    Q(question__startswith='Who'),
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
```

… roughly translates into the SQL:

```
SELECT * from polls WHERE question LIKE 'Who%'
    AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')
```

Lookup functions can mix the use of `Q` objects and keyword arguments. All arguments provided to a lookup function (be they keyword arguments or `Q` objects) are “AND”ed together. However, if a `Q` object is provided, it must precede the definition of any keyword arguments. For example:

```
Poll.objects.get(
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
    question__startswith='Who',
)
```

… would be a valid query, equivalent to the previous example; but:

```
# INVALID QUERY
Poll.objects.get(
    question__startswith='Who',
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
```

… would not be valid.

See also

The [OR lookups examples](https://github.com/django/django/blob/master/tests/or_lookups/tests.py) in the Django unit tests show some possible uses of `Q`.





